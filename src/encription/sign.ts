import { createSign, createVerify } from "crypto";
import BufferReader from "../encoding/bufferReader";
import { DataModificationError } from "../erros";
import { bufferToShortNumber, extractDynamicBuffer, shortNumberToBuffer, stringToBuffer } from "../encoding";
import { Buffer } from "buffer";

import { KeyObject } from "../types";

const hash = "SHA512";

/**
 * Signs some data with an ECDSA key but does not include metadata for serialization.
 * @param data the data to be used
 * @param key the key used to sign the data
 * @returns the signature of the data without metadata
 */
function sign_nonstreamable(data: Buffer, key: KeyObject) {
    const sign = createSign(hash)

    sign.update(data);
    sign.end();
    return sign.sign(key);
}

/**
 * Crates a ECDSA signature of some data, it requires the sign key. It uses the short Numer encoder as signature length is < 256.
 * @param data {string} - the data to sign
 * @param key{KeyObject} - the private key to use for signing
 */
function sign(data: Buffer, key: KeyObject) {
    const sig = sign_nonstreamable(data, key);
    return Buffer.concat([
        stringToBuffer(sig, shortNumberToBuffer),
        data
    ])
}

/**
 * verifies if the signature matches the data.
 * @param data the data the signature claims to verify
 * @param sig the signature of the data
 * @param key the public key of the person claiming to have sent the data
 * @returns true if the data is safe
 */
function verify_nonstreamable(data: Buffer, sig: Buffer, key: KeyObject) {
    const verify = createVerify(hash);
    verify.update(data);
    verify.end();
    return verify.verify(key, sig);
}

/**
 * checks if the data recieved is safe. This requires the public sign key. It uses the short Numer encoder as signature length is < 256.
 * @param data_str {SingedMessage} - the data to check, generated by sign
 * @param key {Keyobject} - the public key used to verify
 */
function verify(reader: BufferReader, key: KeyObject) {
    const signature = extractDynamicBuffer(reader, bufferToShortNumber);
    const data = reader.readRest();
    
    return {
        safe: verify_nonstreamable(data, signature, key),
        data
    }
}

/**
 * checks if the data recieved is safe. This requires the public sign key. If it is not an error will be thrown
 * @param data_str {SingedMessage} - the data to check, generated by sign
 * @param key {Keyobject} - the public key used to verify
 */
function verifyAndRaiseError(reader: BufferReader, key: KeyObject) {
    const { safe, data, } = verify(reader, key);
    if (!safe){
        throw unsafe_error;
    }
    return data
}

const unsafe_error =  new DataModificationError("the signature of the message does not match its content");

export { sign, verify, verifyAndRaiseError, verify_nonstreamable, sign_nonstreamable, unsafe_error }