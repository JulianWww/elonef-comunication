import BufferReader from "../encoding/bufferReader";
import { DataModificationError } from "../erros";
import { sign as _sign, verify as _verify } from "eccrypto";
import { bufferToShortNumber, extractDynamicBuffer, shortNumberToBuffer, stringToBuffer } from "../encoding";
import { sha512 as hash } from "crypto-hash";
import { Buffer } from "buffer";


async function sha512(data: Buffer) {
    return Buffer.from(await hash(data), "hex")
}

/**
 * Signs some data with an ECDSA key but does not include metadata for serialization.
 * @param data the data to be used
 * @param key the key used to sign the data
 * @returns the signature of the data without metadata
 */
async function sign_nonstreamable(data: Buffer, key: Buffer) {
    const hash = await sha512(data)
    return _sign(key, hash)
}

/**
 * Crates a ECDSA signature of some data, it requires the sign key. It uses the short Numer encoder as signature length is < 256.
 * @param data {string} - the data to sign
 * @param key{Buffer} - the private key to use for signing
 */
async function sign(data: Buffer, key: Buffer) {
    const sig = sign_nonstreamable(data, key);
    return Buffer.concat([
        stringToBuffer(await sig, shortNumberToBuffer),
        data
    ])
}

/**
 * verifies if the signature matches the data.
 * @param data the data the signature claims to verify
 * @param sig the signature of the data
 * @param key the public key of the person claiming to have sent the data
 * @returns true if the data is safe
 */
async function verify_nonstreamable(data: Buffer, sig: Buffer, key: Buffer) {
    const hash = await sha512(data);
    return _verify(key, hash, sig)
}

/**
 * checks if the data recieved is safe. This requires the public sign key. It uses the short Numer encoder as signature length is < 256.
 * @param data_str {SingedMessage} - the data to check, generated by sign
 * @param key {Buffer} - the public key used to verify
 */
async function verify(reader: BufferReader, key: Buffer) {
    const signature = extractDynamicBuffer(reader, bufferToShortNumber);
    const data = reader.readRest();
    
    return {
        safe: await verify_nonstreamable(data, signature, key),
        data
    }
}

/**
 * checks if the data recieved is safe. This requires the public sign key. If it is not an error will be thrown
 * @param data_str {SingedMessage} - the data to check, generated by sign
 * @param key {Buffer} - the public key used to verify
 */
async function verifyAndRaiseError(reader: BufferReader, key: Buffer) {
    const { safe, data, } = await verify(reader, key);
    if (!safe){
        throw unsafe_error;
    }
    return data
}

const unsafe_error =  new DataModificationError("the signature of the message does not match its content");

export { sign, verify, verifyAndRaiseError, verify_nonstreamable, sign_nonstreamable, unsafe_error }